<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>åœ£è¯æ ‘ | äº’åŠ¨ç²’å­ç³»ç»Ÿ</title>
    
    <!-- Google Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">
    
    <!-- ä½¿ç”¨æœ¬åœ°Three.jsåº“ -->
    <script src="lib/three.min.js"></script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            font-family: 'Times New Roman', serif;
            background: #000000;
            color: #fceea7;
            overflow: hidden;
            width: 100vw;
            height: 100vh;
            touch-action: none;
        }

        /* åŠ è½½å™¨ */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #000000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            transition: opacity 0.8s ease;
        }

        .loader.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(212, 175, 55, 0.2);
            border-radius: 50%;
            border-top: 4px solid #d4af37;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .loader-text {
            font-size: 18px;
            color: #d4af37;
            letter-spacing: 2px;
            text-align: center;
            padding: 0 20px;
        }

        .loader-progress {
            width: 200px;
            height: 2px;
            background: rgba(212, 175, 55, 0.2);
            border-radius: 1px;
            margin-top: 20px;
            overflow: hidden;
        }

        .progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #d4af37, #fceea7);
            transition: width 0.3s ease;
        }

        /* UIå®¹å™¨ */
        .ui-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
            padding: 20px;
        }

        .ui-container.ui-hidden {
            opacity: 0;
        }

        .ui-container > * {
            pointer-events: auto;
        }

        /* æ ‡é¢˜ */
        header {
            text-align: center;
            padding-top: 30px;
            pointer-events: none;
        }

        h1 {
            font-family: 'Cinzel', serif;
            font-size: 56px;
            background: linear-gradient(to bottom, #fceea7, #d4af37);
            -webkit-background-clip: text;
            background-clip: text;
            color: transparent;
            text-shadow: 0 0 20px rgba(212, 175, 55, 0.5);
            margin-bottom: 10px;
        }

        /* ä¸Šä¼ æŒ‰é’® */
        .upload-wrapper {
            position: absolute;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 90%;
            max-width: 500px;
        }

        .upload-btn {
            background: rgba(212, 175, 55, 0.1);
            backdrop-filter: blur(10px);
            border: 2px solid #d4af37;
            color: #fceea7;
            padding: 15px 30px;
            font-size: 18px;
            font-family: 'Cinzel', serif;
            cursor: pointer;
            border-radius: 8px;
            transition: all 0.3s ease;
            margin-bottom: 15px;
            width: 100%;
        }

        .upload-btn:hover {
            background: rgba(212, 175, 55, 0.2);
        }

        .hint-text {
            font-size: 16px;
            color: #d4af37;
            opacity: 0.8;
            letter-spacing: 1px;
            text-align: center;
        }

        /* æ¨¡å¼æŒ‡ç¤ºå™¨ */
        .mode-indicator {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px 15px;
            border-radius: 8px;
            border-left: 4px solid #d4af37;
            backdrop-filter: blur(5px);
            min-width: 200px;
        }

        .mode-text {
            font-size: 16px;
            color: #fceea7;
            font-family: 'Cinzel', serif;
            font-weight: bold;
        }

        .mode-subtext {
            font-size: 14px;
            color: #d4af37;
        }

        /* æ“ä½œè¯´æ˜ */
        .instructions {
            position: absolute;
            top: 120px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 80%;
            max-width: 800px;
        }

        .instructions p {
            font-size: 18px;
            margin-bottom: 10px;
            color: #d4af37;
            line-height: 1.4;
        }

        /* æ‰‹åŠ¿æç¤º */
        .gesture-hint {
            display: flex;
            justify-content: center;
            gap: 30px;
            margin-top: 20px;
            flex-wrap: wrap;
        }

        .gesture-item {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        .gesture-icon {
            font-size: 24px;
            margin-bottom: 8px;
        }

        .gesture-text {
            font-size: 14px;
            color: #fceea7;
        }

        /* Three.jsç”»å¸ƒ */
        #canvas3d {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            outline: none;
            touch-action: none;
        }

        /* ç§»åŠ¨ç«¯é€‚é… */
        @media screen and (max-width: 768px) {
            h1 {
                font-size: 32px !important;
                padding-top: 20px;
            }
            
            .instructions {
                top: 80px;
            }
            
            .instructions p {
                font-size: 14px;
            }
            
            .gesture-hint {
                gap: 15px;
            }
            
            .gesture-item {
                width: 30%;
            }
            
            .upload-wrapper {
                bottom: 70px;
                width: 95%;
            }
            
            .upload-btn {
                padding: 12px 20px;
                font-size: 16px;
            }
            
            .hint-text {
                font-size: 14px;
            }
            
            .mode-indicator {
                top: 10px;
                right: 10px;
                left: 10px;
                padding: 8px 12px;
                text-align: center;
            }
            
            .mode-text {
                font-size: 14px;
            }
            
            .mode-subtext {
                font-size: 12px;
            }
        }

        @media screen and (max-width: 480px) {
            h1 {
                font-size: 28px !important;
                margin-bottom: 5px;
            }
            
            .gesture-hint {
                gap: 10px;
            }
            
            .gesture-item {
                width: 45%;
            }
            
            .upload-wrapper {
                bottom: 60px;
            }
            
            .upload-btn {
                padding: 10px 15px;
                font-size: 15px;
            }
        }

        @media screen and (orientation: landscape) and (max-height: 600px) {
            h1 {
                font-size: 24px !important;
                padding-top: 5px;
            }
            
            .instructions {
                top: 60px;
            }
            
            .instructions p {
                font-size: 12px;
            }
            
            .gesture-hint {
                display: none;
            }
            
            .upload-wrapper {
                bottom: 50px;
                width: 80%;
            }
        }
    </style>
</head>
<body>
    <!-- åŠ è½½å™¨ -->
    <div class="loader" id="loader">
        <div class="spinner"></div>
        <div class="loader-text">æ­£åœ¨åŠ è½½èŠ‚æ—¥é­”æ³•</div>
        <div class="loader-progress" id="loaderProgress">
            <div class="progress-bar"></div>
        </div>
    </div>

    <!-- ä¸»UIå®¹å™¨ -->
    <div class="ui-container" id="uiContainer">
        <header>
            <h1>åœ£è¯å¿«ä¹</h1>
        </header>

        <!-- æ“ä½œè¯´æ˜ -->
        <div class="instructions">
            <p id="desktopInstruction">æŒ‰ H é”®éšè—æ§åˆ¶é¢æ¿ï¼Œç©ºæ ¼é”®åˆ‡æ¢æ¨¡å¼</p>
            <p id="mobileInstruction" style="display: none;">å•æŒ‡æ‹–åŠ¨æ—‹è½¬åœºæ™¯ï¼ŒåŒå‡»éšè—æ§åˆ¶é¢æ¿</p>
            <div class="gesture-hint" id="gestureHint">
                <div class="gesture-item">
                    <div class="gesture-icon">ğŸ„</div>
                    <div class="gesture-text">åœ£è¯æ ‘æ¨¡å¼</div>
                </div>
                <div class="gesture-item">
                    <div class="gesture-icon">â„ï¸</div>
                    <div class="gesture-text">æ•£è½æ¨¡å¼</div>
                </div>
                <div class="gesture-item">
                    <div class="gesture-icon">ğŸ“·</div>
                    <div class="gesture-text">æ·»åŠ ç…§ç‰‡</div>
                </div>
            </div>
        </div>

        <!-- æ¨¡å¼æŒ‡ç¤ºå™¨ -->
        <div class="mode-indicator">
            <div class="mode-text" id="modeText">åœ£è¯æ ‘æ¨¡å¼</div>
            <div class="mode-subtext" id="modeSubtext">ç²’å­æ’åˆ—ä¸ºåœ£è¯æ ‘å½¢çŠ¶</div>
        </div>

        <!-- ä¸Šä¼ æ§ä»¶ -->
        <div class="upload-wrapper">
            <button class="upload-btn" id="uploadBtn">æ·»åŠ å›å¿†ç…§ç‰‡</button>
            <div class="hint-text">æŒ‰ H é”®éšè—æ§åˆ¶é¢æ¿</div>
        </div>
    </div>

    <!-- éšè—çš„æ–‡ä»¶è¾“å…¥ -->
    <input type="file" id="fileInput" accept="image/*" style="display: none;">

    <!-- Three.js ç”»å¸ƒ -->
    <canvas id="canvas3d"></canvas>

    <script>
        // =========== Three.jsæœ¬åœ°åŠ è½½æ£€æŸ¥ ===========
        (function checkThreeJS() {
            const loader = document.getElementById('loader');
            const progressBar = document.querySelector('.progress-bar');
            
            // æ£€æŸ¥Three.jsæ˜¯å¦å·²åŠ è½½
            function checkLibrary() {
                if (typeof THREE !== 'undefined') {
                    // Three.jsåŠ è½½æˆåŠŸ
                    console.log('âœ… Three.jsæœ¬åœ°åŠ è½½æˆåŠŸ');
                    progressBar.style.width = '100%';
                    setTimeout(() => {
                        initApp();
                    }, 500);
                    return true;
                } else {
                    // Three.jsæœªåŠ è½½
                    console.error('âŒ Three.jsæœ¬åœ°åŠ è½½å¤±è´¥');
                    return false;
                }
            }
            
            // åˆå§‹æ£€æŸ¥
            if (!checkLibrary()) {
                // å¦‚æœåˆå§‹æ£€æŸ¥å¤±è´¥ï¼Œå°è¯•å»¶è¿Ÿæ£€æŸ¥ï¼ˆç»™æµè§ˆå™¨æ—¶é—´åŠ è½½ï¼‰
                let attempts = 0;
                const maxAttempts = 10;
                
                const interval = setInterval(() => {
                    attempts++;
                    progressBar.style.width = `${attempts * 10}%`;
                    
                    if (checkLibrary()) {
                        clearInterval(interval);
                    } else if (attempts >= maxAttempts) {
                        clearInterval(interval);
                        showLoadError('Three.jsæœ¬åœ°åº“åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥lib/three.min.jsæ–‡ä»¶æ˜¯å¦å­˜åœ¨');
                    }
                }, 300);
            }
        })();
        
        // =========== è®¾å¤‡æ£€æµ‹ ===========
        const deviceDetector = {
            isMobile: /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
            isIOS: /iPad|iPhone|iPod/.test(navigator.userAgent),
            isTouchDevice: 'ontouchstart' in window || navigator.maxTouchPoints > 0,
            getPerformanceLevel() {
                const memory = navigator.deviceMemory || 4;
                const cores = navigator.hardwareConcurrency || 4;
                return memory < 4 || cores < 4 ? 'low' : 'medium';
            }
        };
        
        // =========== ä¸»åº”ç”¨ç±» ===========
        class ChristmasTreeApp {
            constructor() {
                // è®¾å¤‡æ£€æµ‹
                this.isMobile = deviceDetector.isMobile || deviceDetector.isTouchDevice;
                this.performanceLevel = deviceDetector.getPerformanceLevel();
                
                // æ€§èƒ½è®¾ç½®
                this.settings = {
                    particleCount: this.isMobile ? 1200 : 2000,
                    mainParticleCount: this.isMobile ? 400 : 800,
                    enableBloom: this.performanceLevel !== 'low',
                    enableShadows: this.performanceLevel !== 'low',
                    pixelRatio: this.isMobile ? 1.0 : Math.min(1.5, window.devicePixelRatio),
                    renderScale: this.isMobile ? 0.9 : 1.0
                };
                
                // Three.js æ ¸å¿ƒå¯¹è±¡
                this.scene = null;
                this.camera = null;
                this.renderer = null;
                this.clock = new THREE.Clock();
                
                // ç²’å­ç³»ç»Ÿ
                this.mainGroup = new THREE.Group();
                this.particles = [];
                this.photos = [];
                
                // çŠ¶æ€ç®¡ç†
                this.STATE = {
                    mode: 'TREE', // TREE, SCATTER
                    isAnimating: true
                };
                
                // UI å…ƒç´ 
                this.loader = document.getElementById('loader');
                this.uiContainer = document.getElementById('uiContainer');
                this.modeText = document.getElementById('modeText');
                this.modeSubtext = document.getElementById('modeSubtext');
                this.uploadBtn = document.getElementById('uploadBtn');
                this.fileInput = document.getElementById('fileInput');
                this.desktopInstruction = document.getElementById('desktopInstruction');
                this.mobileInstruction = document.getElementById('mobileInstruction');
                this.gestureHint = document.getElementById('gestureHint');
                
                // æ ¹æ®è®¾å¤‡æ˜¾ç¤ºä¸åŒçš„ä½¿ç”¨è¯´æ˜
                if (this.isMobile) {
                    this.desktopInstruction.style.display = 'none';
                    this.mobileInstruction.style.display = 'block';
                    this.gestureHint.style.display = 'flex';
                }
            }
            
            async init() {
                try {
                    // æ£€æŸ¥WebGLæ”¯æŒ
                    if (!this.checkWebGL()) {
                        throw new Error('æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒWebGL');
                    }
                    
                    // åˆå§‹åŒ–Three.js
                    this.initThreeJS();
                    
                    // åˆ›å»ºç²’å­
                    this.createParticles();
                    
                    // åˆ›å»ºé»˜è®¤ç…§ç‰‡
                    this.createDefaultPhoto();
                    
                    // è®¾ç½®äº‹ä»¶ç›‘å¬å™¨
                    this.setupEventListeners();
                    
                    // å¼€å§‹åŠ¨ç”»
                    this.animate();
                    
                    // éšè—åŠ è½½å™¨
                    setTimeout(() => {
                        this.loader.classList.add('hidden');
                    }, 1000);
                    
                    console.log('ğŸ‰ åº”ç”¨åˆå§‹åŒ–æˆåŠŸï¼');
                    
                } catch (error) {
                    console.error('åˆå§‹åŒ–å¤±è´¥:', error);
                    showLoadError(error.message);
                }
            }
            
            checkWebGL() {
                try {
                    const canvas = document.createElement('canvas');
                    const gl = canvas.getContext('webgl') || canvas.getContext('experimental-webgl');
                    return !!gl;
                } catch (e) {
                    return false;
                }
            }
            
            initThreeJS() {
                // åœºæ™¯
                this.scene = new THREE.Scene();
                this.scene.background = new THREE.Color(0x000000);
                
                // ç›¸æœº
                this.camera = new THREE.PerspectiveCamera(
                    60,
                    window.innerWidth / window.innerHeight,
                    0.1,
                    1000
                );
                
                if (this.isMobile) {
                    this.camera.position.set(0, 3, 35);
                    this.camera.fov = 65;
                } else {
                    this.camera.position.set(0, 2, 50);
                }
                
                // æ¸²æŸ“å™¨
                this.renderer = new THREE.WebGLRenderer({
                    canvas: document.getElementById('canvas3d'),
                    antialias: this.performanceLevel !== 'low',
                    alpha: false,
                    powerPreference: 'default'
                });
                
                this.renderer.setPixelRatio(this.settings.pixelRatio);
                this.renderer.setSize(
                    window.innerWidth * this.settings.renderScale,
                    window.innerHeight * this.settings.renderScale
                );
                
                this.renderer.toneMapping = THREE.ReinhardToneMapping;
                this.renderer.toneMappingExposure = this.isMobile ? 1.8 : 2.2;
                this.renderer.outputColorSpace = THREE.SRGBColorSpace;
                this.renderer.shadowMap.enabled = this.settings.enableShadows;
                this.renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                
                // ç¯å…‰
                this.setupLights();
                
                // æ·»åŠ åˆ°åœºæ™¯
                this.scene.add(this.mainGroup);
            }
            
            setupLights() {
                // ç¯å¢ƒå…‰
                const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
                this.scene.add(ambientLight);
                
                // ç‚¹å…‰æº
                const pointLight = new THREE.PointLight(0xff6600, 2, 100);
                pointLight.position.set(5, 10, 5);
                this.scene.add(pointLight);
                
                // é‡‘è‰²èšå…‰ç¯
                const spotLight1 = new THREE.SpotLight(0xd4af37, 1000, 100, Math.PI / 6, 0.5, 1);
                spotLight1.position.set(30, 40, 40);
                spotLight1.castShadow = this.settings.enableShadows;
                if (spotLight1.castShadow) {
                    spotLight1.shadow.mapSize.width = 256;
                    spotLight1.shadow.mapSize.height = 256;
                }
                this.scene.add(spotLight1);
                
                // è“è‰²èšå…‰ç¯
                const spotLight2 = new THREE.SpotLight(0x3399ff, 600, 100, Math.PI / 6, 0.5, 1);
                spotLight2.position.set(-30, 20, -30);
                this.scene.add(spotLight2);
            }
            
            createParticles() {
                const colors = {
                    gold: 0xd4af37,
                    green: 0x1a5f1a,
                    red: 0xff0000,
                    cream: 0xfceea7
                };
                
                // åˆ›å»ºæè´¨
                const goldMaterial = new THREE.MeshStandardMaterial({
                    color: colors.gold,
                    metalness: 0.8,
                    roughness: 0.3
                });
                
                const greenMaterial = new THREE.MeshStandardMaterial({
                    color: colors.green,
                    metalness: 0.3,
                    roughness: 0.8
                });
                
                const redMaterial = new THREE.MeshStandardMaterial({
                    color: colors.red,
                    metalness: 0.5,
                    roughness: 0.4
                });
                
                const dustMaterial = new THREE.MeshStandardMaterial({
                    color: colors.cream,
                    emissive: colors.cream,
                    emissiveIntensity: 0.2
                });
                
                // åˆ›å»ºä¸»ç²’å­
                for (let i = 0; i < this.settings.particleCount; i++) {
                    let geometry, material;
                    
                    if (i < this.settings.mainParticleCount) {
                        // ä¸»ç²’å­
                        const type = i % 4;
                        switch(type) {
                            case 0: // é‡‘è‰²ç›’å­
                                geometry = new THREE.BoxGeometry(0.8, 0.8, 0.8);
                                material = goldMaterial;
                                break;
                            case 1: // ç»¿è‰²ç›’å­
                                geometry = new THREE.BoxGeometry(0.7, 0.7, 0.7);
                                material = greenMaterial;
                                break;
                            case 2: // é‡‘è‰²çƒä½“
                                geometry = new THREE.SphereGeometry(0.5, 16, 16);
                                material = goldMaterial;
                                break;
                            case 3: // çº¢è‰²çƒä½“
                                geometry = new THREE.SphereGeometry(0.6, 16, 16);
                                material = redMaterial;
                                break;
                        }
                    } else {
                        // å°˜åŸƒç²’å­
                        geometry = new THREE.SphereGeometry(
                            0.1 + Math.random() * 0.2,
                            8, 8
                        );
                        material = dustMaterial;
                    }
                    
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.castShadow = this.settings.enableShadows;
                    mesh.receiveShadow = this.settings.enableShadows;
                    
                    const particle = {
                        mesh,
                        basePosition: new THREE.Vector3(),
                        targetPosition: new THREE.Vector3(),
                        velocity: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02
                        ),
                        rotationSpeed: new THREE.Vector3(
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02,
                            (Math.random() - 0.5) * 0.02
                        ),
                        scale: 1,
                        isPhoto: false
                    };
                    
                    this.particles.push(particle);
                    this.mainGroup.add(mesh);
                }
                
                // æ ¹æ®å½“å‰æ¨¡å¼åˆå§‹åŒ–ä½ç½®
                this.updateParticlePositions();
            }
            
            createDefaultPhoto() {
                const canvas = document.createElement('canvas');
                const size = this.isMobile ? 256 : 512;
                canvas.width = size;
                canvas.height = size;
                const ctx = canvas.getContext('2d');
                
                // é‡‘è‰²èƒŒæ™¯
                ctx.fillStyle = '#d4af37';
                ctx.fillRect(0, 0, canvas.width, canvas.height);
                
                // å†…éƒ¨ç™½è‰²åŒºåŸŸ
                ctx.fillStyle = '#fceea7';
                const margin = 20;
                ctx.fillRect(margin, margin, canvas.width - margin * 2, canvas.height - margin * 2);
                
                // æ–‡å­—
                ctx.fillStyle = '#1a5f1a';
                const fontSize = this.isMobile ? 30 : 50;
                ctx.font = `bold ${fontSize}px Cinzel`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('MERRY CHRISTMAS', canvas.width / 2, canvas.height / 2);
                
                // è£…é¥°å…ƒç´ 
                ctx.fillStyle = '#ff0000';
                ctx.beginPath();
                ctx.arc(canvas.width / 2, canvas.height / 3, this.isMobile ? 20 : 30, 0, Math.PI * 2);
                ctx.fill();
                
                const texture = new THREE.CanvasTexture(canvas);
                texture.colorSpace = THREE.SRGBColorSpace;
                
                this.addPhotoToScene(texture);
            }
            
            addPhotoToScene(texture) {
                const frameScale = this.isMobile ? 0.7 : 1.0;
                
                // åˆ›å»ºç›¸æ¡†
                const frameGeometry = new THREE.BoxGeometry(3.5 * frameScale, 4.5 * frameScale, 0.3 * frameScale);
                const frameMaterial = new THREE.MeshStandardMaterial({
                    color: 0xd4af37,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const frame = new THREE.Mesh(frameGeometry, frameMaterial);
                
                // åˆ›å»ºç…§ç‰‡
                const photoGeometry = new THREE.PlaneGeometry(3 * frameScale, 4 * frameScale);
                const photoMaterial = new THREE.MeshStandardMaterial({
                    map: texture,
                    side: THREE.DoubleSide
                });
                const photo = new THREE.Mesh(photoGeometry, photoMaterial);
                photo.position.z = 0.16 * frameScale;
                
                // ç»„åˆç›¸æ¡†å’Œç…§ç‰‡
                const photoGroup = new THREE.Group();
                photoGroup.add(frame);
                photoGroup.add(photo);
                
                // éšæœºä½ç½®
                const angle = Math.random() * Math.PI * 2;
                const radius = 15 + Math.random() * 10;
                photoGroup.position.set(
                    Math.cos(angle) * radius,
                    (Math.random() - 0.5) * 15,
                    Math.sin(angle) * radius
                );
                
                // éšæœºæ—‹è½¬
                photoGroup.rotation.y = Math.random() * Math.PI * 2;
                
                // å­˜å‚¨ç…§ç‰‡æ•°æ®
                const photoParticle = {
                    mesh: photoGroup,
                    basePosition: photoGroup.position.clone(),
                    targetPosition: new THREE.Vector3(),
                    velocity: new THREE.Vector3(),
                    rotationSpeed: new THREE.Vector3(),
                    scale: 1,
                    isPhoto: true
                };
                
                this.particles.push(photoParticle);
                this.photos.push(photoParticle);
                this.mainGroup.add(photoGroup);
            }
            
            updateParticlePositions() {
                const mode = this.STATE.mode;
                
                if (mode === 'TREE') {
                    // åœ£è¯æ ‘æ¨¡å¼ - èºæ—‹åœ†é”¥ä½“
                    const maxRadius = this.isMobile ? 8 : 12;
                    const height = this.isMobile ? 18 : 25;
                    
                    this.particles.forEach((particle, i) => {
                        if (particle.isPhoto) return;
                        
                        const t = i / this.particles.length;
                        const radius = maxRadius * (1 - t * 0.8);
                        const angle = t * 50 * Math.PI;
                        const y = t * height - height / 2;
                        
                        particle.targetPosition.set(
                            Math.cos(angle) * radius,
                            y,
                            Math.sin(angle) * radius
                        );
                        particle.scale = this.isMobile ? 0.8 : 1;
                    });
                    
                } else if (mode === 'SCATTER') {
                    // æ•£è½æ¨¡å¼ - çƒä½“åˆ†å¸ƒ
                    const minRadius = this.isMobile ? 6 : 8;
                    const maxRadius = this.isMobile ? 15 : 20;
                    
                    this.particles.forEach((particle) => {
                        if (particle.isPhoto) return;
                        
                        const radius = minRadius + Math.random() * (maxRadius - minRadius);
                        const theta = Math.random() * Math.PI * 2;
                        const phi = Math.acos(2 * Math.random() - 1);
                        
                        particle.targetPosition.set(
                            radius * Math.sin(phi) * Math.cos(theta),
                            (Math.random() - 0.5) * maxRadius * 1.5,
                            radius * Math.sin(phi) * Math.sin(theta)
                        );
                        particle.scale = 0.8 + Math.random() * 0.4;
                    });
                }
            }
            
            setMode(mode) {
                this.STATE.mode = mode;
                
                switch (mode) {
                    case 'TREE':
                        this.modeText.textContent = 'åœ£è¯æ ‘æ¨¡å¼';
                        this.modeSubtext.textContent = 'ç²’å­æ’åˆ—ä¸ºåœ£è¯æ ‘å½¢çŠ¶';
                        break;
                    case 'SCATTER':
                        this.modeText.textContent = 'æ•£è½æ¨¡å¼';
                        this.modeSubtext.textContent = 'ç²’å­éšæœºæ•£å¸ƒåœ¨ç©ºä¸­';
                        break;
                }
                
                this.updateParticlePositions();
            }
            
            setupEventListeners() {
                // çª—å£å¤§å°è°ƒæ•´
                window.addEventListener('resize', () => {
                    this.camera.aspect = window.innerWidth / window.innerHeight;
                    this.camera.updateProjectionMatrix();
                    
                    this.renderer.setSize(
                        window.innerWidth * this.settings.renderScale,
                        window.innerHeight * this.settings.renderScale
                    );
                });
                
                // é”®ç›˜æ§åˆ¶
                document.addEventListener('keydown', (e) => {
                    switch (e.key.toLowerCase()) {
                        case 'h':
                            // éšè—/æ˜¾ç¤ºUI
                            this.uiContainer.classList.toggle('ui-hidden');
                            break;
                        case ' ':
                            // ç©ºæ ¼é”®åˆ‡æ¢æ¨¡å¼
                            e.preventDefault();
                            const modes = ['TREE', 'SCATTER'];
                            const currentIndex = modes.indexOf(this.STATE.mode);
                            const nextIndex = (currentIndex + 1) % modes.length;
                            this.setMode(modes[nextIndex]);
                            break;
                        case 'escape':
                            // é‡ç½®è§†å›¾
                            this.resetView();
                            break;
                    }
                });
                
                // æ–‡ä»¶ä¸Šä¼ 
                this.uploadBtn.addEventListener('click', () => {
                    this.fileInput.click();
                });
                
                this.fileInput.addEventListener('change', (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (ev) => {
                        new THREE.TextureLoader().load(ev.target.result, (texture) => {
                            texture.colorSpace = THREE.SRGBColorSpace;
                            this.addPhotoToScene(texture);
                        });
                    };
                    reader.readAsDataURL(file);
                    
                    e.target.value = '';
                });
                
                // ç§»åŠ¨ç«¯è§¦æ‘¸æ§åˆ¶
                if (this.isMobile) {
                    this.setupTouchControls();
                } else {
                    // æ¡Œé¢ç«¯é¼ æ ‡æ§åˆ¶
                    this.setupMouseControls();
                }
                
                // é˜²æ­¢é¡µé¢æ»šåŠ¨
                document.addEventListener('touchmove', (e) => {
                    if (e.target.id === 'canvas3d') {
                        e.preventDefault();
                    }
                }, { passive: false });
                
                // é¡µé¢å¯è§æ€§
                document.addEventListener('visibilitychange', () => {
                    if (document.hidden) {
                        this.pause();
                    } else {
                        this.resume();
                    }
                });
            }
            
            setupMouseControls() {
                const canvas = this.renderer.domElement;
                let isDragging = false;
                let lastMouseX = 0;
                let lastMouseY = 0;
                
                canvas.addEventListener('mousedown', (e) => {
                    isDragging = true;
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                });
                
                canvas.addEventListener('mousemove', (e) => {
                    if (!isDragging) return;
                    
                    const deltaX = e.clientX - lastMouseX;
                    const deltaY = e.clientY - lastMouseY;
                    
                    // æ›´æ–°æ—‹è½¬
                    this.mainGroup.rotation.y += deltaX * 0.01;
                    this.mainGroup.rotation.x += deltaY * 0.01;
                    
                    // é™åˆ¶Xè½´æ—‹è½¬
                    this.mainGroup.rotation.x = Math.max(
                        -Math.PI / 3,
                        Math.min(Math.PI / 3, this.mainGroup.rotation.x)
                    );
                    
                    lastMouseX = e.clientX;
                    lastMouseY = e.clientY;
                });
                
                canvas.addEventListener('mouseup', () => {
                    isDragging = false;
                    canvas.style.cursor = 'default';
                });
                
                canvas.addEventListener('mouseleave', () => {
                    isDragging = false;
                    canvas.style.cursor = 'default';
                });
                
                // é¼ æ ‡æ»šè½®ç¼©æ”¾
                canvas.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    const zoomSpeed = 0.1;
                    const zoomDelta = e.deltaY > 0 ? -zoomSpeed : zoomSpeed;
                    
                    this.camera.position.z = THREE.MathUtils.clamp(
                        this.camera.position.z + zoomDelta * 5,
                        10,
                        100
                    );
                });
            }
            
            setupTouchControls() {
                const canvas = this.renderer.domElement;
                let touchStartX = 0;
                let touchStartY = 0;
                let lastTapTime = 0;
                
                canvas.addEventListener('touchstart', (e) => {
                    e.preventDefault();
                    touchStartX = e.touches[0].clientX;
                    touchStartY = e.touches[0].clientY;
                });
                
                canvas.addEventListener('touchmove', (e) => {
                    e.preventDefault();
                    
                    if (e.touches.length === 1) {
                        const touchX = e.touches[0].clientX;
                        const touchY = e.touches[0].clientY;
                        
                        const deltaX = touchX - touchStartX;
                        const deltaY = touchY - touchStartY;
                        
                        // æ›´æ–°æ—‹è½¬
                        this.mainGroup.rotation.y += deltaX * 0.01;
                        this.mainGroup.rotation.x += deltaY * 0.01;
                        
                        // é™åˆ¶Xè½´æ—‹è½¬
                        this.mainGroup.rotation.x = Math.max(
                            -Math.PI / 3,
                            Math.min(Math.PI / 3, this.mainGroup.rotation.x)
                        );
                        
                        touchStartX = touchX;
                        touchStartY = touchY;
                    }
                });
                
                canvas.addEventListener('touchend', (e) => {
                    e.preventDefault();
                    
                    // åŒå‡»æ£€æµ‹
                    const now = Date.now();
                    if (now - lastTapTime < 300) {
                        // åŒå‡» - åˆ‡æ¢UIæ˜¾ç¤º
                        this.uiContainer.classList.toggle('ui-hidden');
                    }
                    lastTapTime = now;
                });
            }
            
            resetView() {
                // é‡ç½®ç›¸æœºä½ç½®
                if (this.isMobile) {
                    this.camera.position.set(0, 3, 35);
                } else {
                    this.camera.position.set(0, 2, 50);
                }
                
                // é‡ç½®æ—‹è½¬
                this.mainGroup.rotation.x = 0;
                this.mainGroup.rotation.y = 0;
            }
            
            pause() {
                this.STATE.isAnimating = false;
                this.clock.stop();
            }
            
            resume() {
                this.STATE.isAnimating = true;
                this.clock.start();
            }
            
            animate() {
                if (!this.STATE.isAnimating) return;
                
                requestAnimationFrame(() => this.animate());
                
                const delta = this.clock.getDelta();
                const time = this.clock.getElapsedTime();
                
                // åŠ¨ç”»ç²’å­åˆ°ç›®æ ‡ä½ç½®
                const animationSpeed = this.isMobile ? 0.03 : 0.05;
                
                this.particles.forEach((particle) => {
                    // ä½ç½®æ’å€¼
                    particle.mesh.position.lerp(particle.targetPosition, animationSpeed);
                    
                    // ç¼©æ”¾æ’å€¼
                    particle.mesh.scale.lerp(
                        new THREE.Vector3(particle.scale, particle.scale, particle.scale),
                        0.05
                    );
                    
                    // æ•£è½æ¨¡å¼ä¸‹çš„è‡ªè½¬
                    if (this.STATE.mode === 'SCATTER' && !particle.isPhoto) {
                        particle.mesh.rotation.x += particle.rotationSpeed.x;
                        particle.mesh.rotation.y += particle.rotationSpeed.y;
                        particle.mesh.rotation.z += particle.rotationSpeed.z;
                    }
                    
                    // è½»å¾®æµ®åŠ¨æ•ˆæœ
                    if (!particle.isPhoto) {
                        particle.mesh.position.y += Math.sin(time + particle.mesh.id) * 0.005;
                    }
                });
                
                // æ¸²æŸ“
                this.renderer.render(this.scene, this.camera);
            }
        }
        
        // =========== å…¨å±€å‡½æ•° ===========
        function initApp() {
            try {
                const app = new ChristmasTreeApp();
                app.init();
                window.app = app;
                
                // é¡µé¢å¸è½½æ—¶æ¸…ç†
                window.addEventListener('beforeunload', () => {
                    if (app.renderer) {
                        app.renderer.dispose();
                    }
                });
                
            } catch (error) {
                console.error('åº”ç”¨åˆå§‹åŒ–å¤±è´¥:', error);
                showLoadError('åº”ç”¨åˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        }
        
        function showLoadError(message) {
            document.body.innerHTML = `
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #000;
                    color: #fceea7;
                    display: flex;
                    flex-direction: column;
                    justify-content: center;
                    align-items: center;
                    text-align: center;
                    padding: 20px;
                ">
                    <h1 style="color: #d4af37; margin-bottom: 20px;">ğŸ„ åœ£è¯å¿«ä¹ ğŸ…</h1>
                    <p style="margin-bottom: 10px; color: #ff6b6b;">åŠ è½½é”™è¯¯: ${message}</p>
                    <p style="margin-bottom: 30px; max-width: 600px;">
                        è¿™å¯èƒ½æ˜¯å› ä¸ºç¼ºå°‘Three.jsåº“æ–‡ä»¶ã€‚
                    </p>
                    <div style="text-align: left; margin-bottom: 30px; background: rgba(212, 175, 55, 0.1); padding: 15px; border-radius: 8px;">
                        <h3 style="color: #d4af37; margin-bottom: 10px;">è§£å†³æ–¹æ¡ˆï¼š</h3>
                        <ol style="margin: 15px 0; padding-left: 20px;">
                            <li>ä¸‹è½½Three.jsåº“æ–‡ä»¶ï¼š<br>
                                <a href="https://unpkg.com/three@0.160.0/build/three.min.js" style="color: #d4af37; word-break: break-all;" target="_blank">
                                    https://unpkg.com/three@0.160.0/build/three.min.js
                                </a>
                            </li>
                            <li>åœ¨é¡¹ç›®æ ¹ç›®å½•åˆ›å»º <code>lib</code> æ–‡ä»¶å¤¹</li>
                            <li>å°†ä¸‹è½½çš„ three.min.js æ”¾å…¥ lib/ æ–‡ä»¶å¤¹</li>
                            <li>ç¡®ä¿æ–‡ä»¶ç»“æ„ä¸ºï¼š<br>
                                <code>project/<br>
                                &nbsp;&nbsp;â”œâ”€â”€ lib/<br>
                                &nbsp;&nbsp;â”‚&nbsp;&nbsp;&nbsp;â””â”€â”€ three.min.js<br>
                                &nbsp;&nbsp;â””â”€â”€ christmas-tree.html</code>
                            </li>
                        </ol>
                    </div>
                    <div>
                        <button onclick="location.reload()" style="
                            background: #d4af37;
                            color: #000;
                            border: none;
                            padding: 12px 24px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 16px;
                            margin: 10px;
                        ">åˆ·æ–°é¡µé¢</button>
                        <button onclick="window.open('https://get.webgl.org/', '_blank')" style="
                            background: transparent;
                            color: #fceea7;
                            border: 1px solid #d4af37;
                            padding: 12px 24px;
                            border-radius: 6px;
                            cursor: pointer;
                            font-size: 16px;
                            margin: 10px;
                        ">æ£€æŸ¥WebGLæ”¯æŒ</button>
                    </div>
                </div>
            `;
        }
    </script>
</body>
</html>